#AUTOGENERATED! DO NOT EDIT! File to edit: dev/modules.ipynb (unless otherwise specified).

__all__ = ['tensors2parameters', 'floats2parameters', 'Inversible', 'Inverse', 'assert_inversible', 'Translation',
           'Rotation', 'R2euler', 'euler2R', 'EulerRotation', 'InversibleSequential', 'Rt2M', 'M2Rt', 'invert_rigid',
           'Rigid', 'Rigids', 'Normalize', 'Augment', 'NoDistortion', 'Heikkila97Distortion', 'Wang08Distortion', 'a2A',
           'Cam', 'CamSF']

#Cell
import torch
import torch.nn as nn

from .utils import *

#Cell
def tensors2parameters(*args):
    params = [nn.Parameter(arg) for arg in args]
    return params[0] if len(params) == 1 else params

#Cell
def floats2parameters(*args):
    return tensors2parameters(*[torch.tensor(arg, dtype=torch.float) for arg in args])

#Cell
class Inversible(nn.Module):
    def __init__(self):
        super().__init__()

    def forward_param(self): raise NotImplementedError('Please implement forward_param() method')
    def inverse_param(self): raise NotImplementedError('Please implement inverse_param() method')

    # Call this method to get a copy of "inverse aware" reconstructed parameters
    def get_param(self):
        with torch.no_grad():
            return self.forward_param().detach().clone()

    def inverse(self): raise NotImplementedError('Please implement inverse() method')

#Cell
class Inverse(Inversible): # Note that Inverse is itself Inversible...
    def __init__(self, m):
        super().__init__()
        self.m = m

    def __repr__(self):
        return f"{self.__class__.__name__}({self.m.__repr__()})"

    def forward_param(self): return self.m.inverse_param()
    def inverse_param(self): return self.m.forward_param()

    def forward(self, x): return self.m.inverse(x)
    def inverse(self, x): return self.m.forward(x)

#Cell
def assert_inversible(m, x, y, **kwargs):
    assert_allclose(m(x),          y, **kwargs)
    assert_allclose(Inverse(m)(y), x, **kwargs)

#Cell
class Translation(Inversible):
    def __init__(self, t):
        super().__init__()
        self.t = tensors2parameters(t)

    def __repr__(self):
        return f'{self.__class__.__name__}(tx:{self.t[0]:.4} ty:{self.t[1]:.4} tz:{self.t[2]:.4})'

    def forward_param(self): return  self.t
    def inverse_param(self): return -self.forward_param()

    def forward(self, ps, inverse=False):
        t = self.forward_param() if not inverse else self.inverse_param()
        return ps + t
    def inverse(self, ps): return self.forward(ps, inverse=True)

#Cell
class Rotation(Inversible):
    def __init__(self):
        super().__init__()

    def r2R(self):
        raise NotImplementedError('Please implement rotation matrix reconstruction')

    def forward_param(self): return self.r2R()
    def inverse_param(self): return self.forward_param().T

    def forward(self, ps, inverse=False):
        R = self.forward_param() if not inverse else self.inverse_param()
        return pmm(R, ps)
    def inverse(self, ps): return self.forward(ps, inverse=True)

#Cell
def R2euler(R):
    atan2 = torch.atan2

    return (atan2(R[2, 1], R[2, 2]),
            atan2(-R[2, 0], torch.sqrt(R[0, 0]**2+R[1, 0]**2)),
            atan2(R[1, 0], R[0, 0]))

#Cell
def euler2R(e_x, e_y, e_z):
    s, c = torch.sin, torch.cos
    stack = torch.stack

    return stack([
        stack([c(e_y)*c(e_z), c(e_z)*s(e_x)*s(e_y) - c(e_x)*s(e_z), s(e_x)*s(e_z) + c(e_x)*c(e_z)*s(e_y)]),
        stack([c(e_y)*s(e_z), c(e_x)*c(e_z) + s(e_x)*s(e_y)*s(e_z), c(e_x)*s(e_y)*s(e_z) - c(e_z)*s(e_x)]),
        stack([      -s(e_y),                        c(e_y)*s(e_x),                        c(e_x)*c(e_y)])
    ])

#Cell
class EulerRotation(Rotation):
    def __init__(self, R):
        super().__init__()
        self.ex, self.ey, self.ez = tensors2parameters(*R2euler(R))

    def __repr__(self):
        return f'{self.__class__.__name__}(ex:{self.ex:.4} ey:{self.ey:.4} ez:{self.ez:.4})'

    def r2R(self): return euler2R(self.ex, self.ey, self.ez)

#Cell
class InversibleSequential(Inversible):
    def __init__(self, ms):
        super().__init__()
        self.ms = nn.ModuleList(ms)

    def forward(self, x):
        for m in self.ms:
            x = m.forward(x)
        return x

    def inverse(self, x):
        for m in reversed(self.ms):
            x = m.inverse(x)
        return x

#Cell
def Rt2M(R, t):
    M = torch.cat([R, t[:,None]], dim=1)
    M = torch.cat([M, M.new_tensor([[0,0,0,1]])])
    return M

#Cell
def M2Rt(M): return M[0:3,0:3], M[0:3,3]

#Cell
def invert_rigid(M):
    R, t = M2Rt(M)
    return Rt2M(R.T, -R.T@t)

#Cell
class Rigid(InversibleSequential):
    def __init__(self, R, t, Rotation=EulerRotation):
        super().__init__([Rotation(R), Translation(t)]) # NOTE: rotation happens first

    def forward_param(self):
        return Rt2M(self.ms[0].forward_param(), # R
                    self.ms[1].forward_param()) # t

    def inverse_param(self): return invert_rigid(self.forward_param())

#Cell
class Rigids(InversibleSequential):
    def __init__(self, rigids):
        super().__init__(rigids)

    def forward_param(self):
        M = torch.eye(4)
        for m in self.ms:
            M = mult_rigid(m.forward_param(), M)
        return M

    def inverse_param(self): return invert_rigid(self.forward_param())

#Cell
class Normalize(nn.Module): # Note: Not Inversible
    def __init__(self):
        super().__init__()

    def forward(self, ps): return normalize(ps)

#Cell
class Augment(Inversible):
    def __init__(self):
        super().__init__()

    def forward(self, ps): return augment(ps)
    def inverse(self, ps): return deaugment(ps) # NOTE: Might need to add assert to test if last column is ones

#Cell
class NoDistortion(nn.Module):
    def __init__():
        super().__init__()

    def forward(self, ps): return ps

#Cell
class Heikkila97Distortion(nn.Module):
    def __init__(self, k1, k2, p1, p2):
        super().__init__()
        self.k1, self.k2, self.p1, self.p2 = floats2parameters(k1, k2, p1, p2)

    def __repr__(self):
        return f'{self.__class__.__name__}(k1:{self.k1:.4} k2:{self.k2:.4} p1:{self.p1:.4} p2:{self.p2:.4})'

    def forward(self, ps):
        xs, ys = ps[:,0], ps[:,1]

        # Radial distortion
        k1, k2 = self.k1, self.k2
        rs = xs**2 + ys**2
        xs_r = xs*(1 + k1*rs + k2*rs**2)
        ys_r = ys*(1 + k1*rs + k2*rs**2)

        # Decentering distortion
        p1, p2 = self.p1, self.p2
        xs_d = xs_r + 2*p1*xs*ys + p2*(3*xs**2 + ys**2)
        ys_d = ys_r + p1*(xs**2 + 3*ys**2) + 2*p2*xs*ys

        return torch.stack([xs_d, ys_d]).T

#Cell
class Wang08Distortion(nn.Module):
    def __init__(self, k1, k2, p, t):
        super().__init__()
        self.k1, self.k2, self.p, self.t = floats2parameters(k1, k2, p, t)

    def __repr__(self):
        return f'{self.__class__.__name__}(k1:{self.k1:.4} k2:{self.k2:.4} p:{self.p:.4} t:{self.t:.4})'

    def forward(self, ps):
        xs, ys = ps[:,0], ps[:,1]

        # Radial distortion
        k1, k2 = self.k1, self.k2
        rs = xs**2 + ys**2
        xs_r = xs*(1 + k1*rs + k2*rs**2)
        ys_r = ys*(1 + k1*rs + k2*rs**2)

        # Image plane (small angle approximation) rotation distortion
        p, t = self.p, self.t
        xs_d = xs_r/(-p*xs_r + t*ys_r + 1)
        ys_d = ys_r/(-p*xs_r + t*ys_r + 1)

        return torch.stack([xs_d, ys_d]).T

#Cell
def a2A(alpha_x, alpha_y, x_o, y_o):
    stack = torch.stack
    zero, one = alpha_x.new_zeros(1)[0], alpha_x.new_ones(1)[0]
    return stack([
        stack([alpha_x,    zero, x_o]),
        stack([   zero, alpha_y, y_o]),
        stack([   zero,    zero, one])
    ])

#Cell
class Cam(Inversible):
    def __init__(self):
        super().__init__()

    def a2A(self):
        raise NotImplementedError('Please implement camera matrix reconstruction')

    def forward_param(self): return self.a2A()
    def inverse_param(self): return torch.inverse(self.forward_param()) # Overwrite this in child classes

    def forward(self, ps, inverse=False):
        A = self.forward_param() if not inverse else self.inverse_param()
        return pmm(A, ps)
    def inverse(self, ps): return self.forward(ps, inverse=True)

#Cell
class CamSF(Cam):
    def __init__(self, A):
        super().__init__()
        assert_allclose(A[0,0], A[1,1]) # Ensures only alpha_x and alpha_y are the same
        self.alpha, self.x_o, self.y_o = tensors2parameters(A[0,0], A[0,2], A[1,2])

    def __repr__(self):
        return f'{self.__class__.__name__}(alpha:{self.alpha:.4} x_o:{self.x_o:.4} y_o:{self.y_o:.4})'

    def a2A(self):
        return a2A(alpha_x=self.alpha, alpha_y=self.alpha, x_o=self.x_o, y_o=self.y_o)

    def inverse_param(self): # Overwrite parent method
        return a2A(alpha_x=1/self.alpha,
                   alpha_y=1/self.alpha,
                   x_o=-self.x_o/self.alpha,
                   y_o=-self.y_o/self.alpha)