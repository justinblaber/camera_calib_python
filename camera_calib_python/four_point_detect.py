#AUTOGENERATED! DO NOT EDIT! File to edit: dev/four_point_detect.ipynb (unless otherwise specified).

__all__ = ['imresize', 'normalize', 'plot_fp', 'DotVisionCheckerDLDetector']

#Cell
import matplotlib.pyplot as plt
import numpy as np
import torch
from PIL import Image
from skimage.measure import label, regionprops
from torchvision import transforms

from .utils import torch2np

#Cell
def imresize(arr, sz):
    pim = Image.fromarray(arr)
    pim = transforms.functional.resize(pim, sz)
    return np.array(pim)

#Cell
def normalize(arr, r1, r2):
    return (arr-r1[0])/(r1[1]-r1[0])*(r2[1]-r2[0])+r2[0]

#Cell
def plot_fp(arr, p_fp, figsize=(10,10)):
    plt.figure(figsize=figsize)
    plt.imshow(arr, cmap='gray')
    for idx in range(len(p_fp)):
        plt.text(p_fp[idx,0], p_fp[idx,1], str(idx+1), color='w', fontsize=12)
    plt.plot(p_fp[:,0], p_fp[:,1], 'r')

#Cell
class DotVisionCheckerDLDetector():
    def __init__(self, file_model, cuda=False):
        model = torch.jit.load(file_model.as_posix())
        model = model.cuda() if cuda else model.cpu()
        model = model.eval()

        self.cuda  = cuda
        self.model = model

    def format_img(self, img):
        gsa = imresize(img.array_gs, 384)           # Network trained on grayscale 384 sized images
        gsa = normalize(gsa, (0, 1), (-1, 1))       # Network trained on images between [-1,1]
        gsa = transforms.functional.to_tensor(gsa)  # Tensorify
        gsa = gsa[None]                             # Add batch dimension
        if self.cuda: gsa = gsa.cuda()              # Possibly run on gpu
        return gsa

    def get_mask(self, img):
        model = self.model
        with torch.no_grad():
            mask = model(self.format_img(img))      # Inference
            mask = torch2np(mask)                   # Convert to numpy
            mask = mask.argmax(axis=1)              # Convert from scores to labels
            mask = mask.squeeze(0)                  # Remove batch dimension
        return mask

    def __call__(self, img):
        mask = self.get_mask(img)

        # Extract four points from mask
        p_fp = np.zeros((4,2))*float('nan')
        for idx in range(len(p_fp)):
            l = label(mask == (idx+1))
            regions = regionprops(l)
            if len(regions) > 0:
                region = regions[np.argmax([r.area for r in regions])]
                p_fp[idx, 0] = region.centroid[1]
                p_fp[idx, 1] = region.centroid[0]
        p_fp *= np.mean([img.size[idx]/mask.shape[idx] for idx in range(2)]) # May not be strictly correct

        return p_fp