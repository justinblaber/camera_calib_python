#AUTOGENERATED! DO NOT EDIT! File to edit: dev/point_refine.ipynb (unless otherwise specified).

__all__ = ['grad_array', 'array_bb', 'bb_grid', 'grid2ps', 'array_ps', 'bb_array', 'norm_mat', 'sample_2pi',
           'sample_ellipse', 'ellipse2conic', 'conic2ellipse', 'checker_opencv', 'fit_conic', 'ellipse_dualconic']

#Cell
import numpy as np

from .utils import augment, deaugment, pmm, reverse, wlstsq

#Cell
def grad_array(arr): return reverse(np.gradient(arr))

#Cell
def array_bb(arr): return np.array([[0,0], [arr.shape[1], arr.shape[0]]])

#Cell
def bb_grid(bb): return reverse(np.mgrid[bb[0,1]:bb[1,1], bb[0,0]:bb[1,0]])

#Cell
def grid2ps(X,Y): return np.c_[X.ravel(), Y.ravel()]

#Cell
def array_ps(arr): return grid2ps(*bb_grid(array_bb(arr)))

#Cell
def bb_array(arr, bb): return arr[bb[0,1]:bb[1,1], bb[0,0]:bb[1,0]]

#Cell
def norm_mat(ps):
    xs, ys = ps[:, 0], ps[:, 1]
    mean_x, mean_y = xs.mean(), ys.mean()
    s_m = np.sqrt(2)*len(ps)/(np.sqrt((xs-mean_x)**2+(ys-mean_y)**2)).sum()
    return np.array([[s_m,   0, -mean_x*s_m],
                     [  0, s_m, -mean_y*s_m],
                     [  0,   0,           1]], dtype=np.float)

#Cell
def sample_2pi(num_samples): return np.linspace(0, 2*np.pi, num_samples+1)[:-1]

#Cell
def sample_ellipse(h, k, a, b, alpha, num_samples):
    sin, cos = np.sin, np.cos

    thetas = sample_2pi(num_samples)
    return np.c_[a*cos(alpha)*cos(thetas) - b*sin(alpha)*sin(thetas) + h,
                 a*sin(alpha)*cos(thetas) + b*cos(alpha)*sin(thetas) + k]

#Cell
def ellipse2conic(h, k, a, b, alpha):
    sin, cos = np.sin, np.cos

    A = a**2*sin(alpha)**2 + b**2*cos(alpha)**2
    B = 2*(b**2 - a**2)*sin(alpha)*cos(alpha)
    C = a**2*cos(alpha)**2 + b**2*sin(alpha)**2
    D = -2*A*h - B*k
    E = -B*h - 2*C*k
    F = A*h**2 + B*h*k + C*k**2 - a**2*b**2

    return np.array([[  A, B/2, D/2],
                     [B/2,   C, E/2],
                     [D/2, E/2,   F]], dtype=np.float)

#Cell
def conic2ellipse(Aq):
    sqrt, abs, arctan, pi = np.sqrt, np.abs, np.arctan, np.pi
    eps = np.finfo(np.float32).eps # Use single precision for more wiggle room

    A = Aq[0, 0]
    B = 2*Aq[0, 1]
    C = Aq[1, 1]
    D = 2*Aq[0, 2]
    E = 2*Aq[1, 2]
    F = Aq[2, 2]

    # Return nans if input conic is not ellipse
    if np.any(~np.isfinite(Aq.ravel())) or np.abs(B**2-4*A*C) < eps or B**2-4*A*C > 0:
        return np.full(5, np.nan)

    # Equations below are from https://math.stackexchange.com/a/820896/39581

    # "coefficient of normalizing factor"
    q = 64*(F*(4*A*C-B**2)-A*E**2+B*D*E-C*D**2)/(4*A*C-B**2)**2

    # distance between center and focal point
    s = 1/4*sqrt(abs(q)*sqrt(B**2+(A-C)**2))

    # ellipse parameters
    h = (B*E-2*C*D)/(4*A*C-B**2)
    k = (B*D-2*A*E)/(4*A*C-B**2)
    a = 1/8*sqrt(2*abs(q)*sqrt(B**2+(A-C)**2)-2*q*(A+C))
    b = sqrt(a**2-s**2)
    # Get alpha; note that range of alpha is [0, pi)
    if abs(q*A-q*C) < eps and abs(q*B) < eps:         alpha = 0 # Circle
    elif abs(q*A-q*C) < eps and q*B > 0:              alpha = 1/4*pi
    elif abs(q*A-q*C) < eps and q*B < 0:              alpha = 3/4*pi
    elif q*A-q*C > 0 and (abs(q*B) < eps or q*B > 0): alpha = 1/2*arctan(B/(A-C))
    elif q*A-q*C > 0 and q*B < 0:                     alpha = 1/2*arctan(B/(A-C)) + pi
    elif q*A-q*C < 0:                                 alpha = 1/2*arctan(B/(A-C)) + 1/2*pi
    else: raise RuntimeError('"Impossible" condition reached; please debug')

    return h, k, a, b, alpha

#Cell
def checker_opencv(arr_dx, arr_dy, W=None):
    # Get normalized array points
    ps = array_ps(arr_dx)
    T = norm_mat(ps)
    ps_norm = pmm(T, ps, aug_ps=True)

    # Form linear system
    A = grid2ps(arr_dx, arr_dy)
    b = (A*ps_norm).sum(axis=1)

    # Get weighted least squares estimate
    p,_,_,_ = wlstsq(A, b, W)

    # Convert back to unnormalized coordinates
    return pmm(np.linalg.inv(T), p, aug_ps=True)

#Cell
def fit_conic(arr_dx, arr_dy, W=None):
    # Get normalized array points
    ps = array_ps(arr_dx)
    T = norm_mat(ps)
    ps_norm = pmm(T, ps, aug_ps=True)

    # Form homogeneous coordinates of lines
    ls = grid2ps(arr_dx, arr_dy)
    ls = np.c_[ls, -(ls*ps_norm).sum(axis=1)]

    # Form linear system
    A = np.c_[ls[:, 0]**2, ls[:, 0]*ls[:, 1], ls[:, 1]**2, ls[:, 0]*ls[:, 2], ls[:, 1]*ls[:, 2]]
    b = -ls[:, 2]**2

    # Get weighted least squares estimate
    aq_inv,_,_,_ = wlstsq(A, b, W)

    # Get conic matrix
    Aq_inv = np.array([[  aq_inv[0], aq_inv[1]/2, aq_inv[3]/2],
                       [aq_inv[1]/2,   aq_inv[2], aq_inv[4]/2],
                       [aq_inv[3]/2, aq_inv[4]/2,           1]], np.float)
    Aq = np.linalg.inv(Aq_inv)

    # Rescale conic matrix to take normalization into account
    return T.T@Aq@T

#Cell
def ellipse_dualconic(arr_dx, arr_dy, W=None):
    Aq = fit_conic(arr_dx, arr_dy, W)
    return conic2ellipse(Aq)