#AUTOGENERATED! DO NOT EDIT! File to edit: dev/fiducial_detect.ipynb (unless otherwise specified).

__all__ = ['imresize', 'normalize', 'DotVisionCheckerDLDetector']

#Cell
import numpy as np
import torch
from PIL import Image
from skimage.measure import label, regionprops
from torchvision import transforms

from .utils import *

#Cell
def imresize(arr, sz):
    pim = Image.fromarray(arr)
    pim = transforms.functional.resize(pim, sz)
    return np.array(pim)

#Cell
def normalize(arr, r1, r2):
    return (arr-r1[0])/(r1[1]-r1[0])*(r2[1]-r2[0])+r2[0]

#Cell
class DotVisionCheckerDLDetector():
    def __init__(self, file_model, cuda=False):
        model = torch.jit.load(file_model.as_posix())
        model = model.cuda() if cuda else model.cpu()
        model = model.eval()

        self.cuda  = cuda
        self.model = model

    def format_img(self, img):
        gsa = imresize(img.array_gs, 384)           # Network trained on grayscale 384 sized images
        gsa = normalize(gsa, (0, 1), (-1, 1))       # Network trained on images between [-1,1]
        gsa = transforms.functional.to_tensor(gsa)  # Tensorify
        gsa = gsa[None]                             # Add batch dimension
        if self.cuda: gsa = gsa.cuda()              # Possibly run on gpu
        return gsa

    def get_mask(self, img):
        model = self.model
        with torch.no_grad():
            mask = model(self.format_img(img))      # Inference
            mask = torch2np(mask)                   # Convert to numpy
            mask = mask.argmax(axis=1)              # Convert from scores to labels
            mask = mask.squeeze(0)                  # Remove batch dimension
        return mask

    def __call__(self, img):
        mask = self.get_mask(img)

        # Extract fiducial points from mask
        ps_f = np.full((4,2), np.nan)
        for idx, p_f in enumerate(ps_f):
            regions = regionprops(label(mask == (idx+1)))
            if len(regions) > 0:
                region = regions[np.argmax([r.area for r in regions])]
                p_f[:] = reverse(region.centroid)
        ps_f *= (img.size/mask.shape).mean() # May not be strictly correct

        return ps_f