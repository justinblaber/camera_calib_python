#AUTOGENERATED! DO NOT EDIT! File to edit: dev/fiducial_detect.ipynb (unless otherwise specified).

__all__ = ['imresize', 'rescale', 'DotVisionCheckerDLDetector']

#Cell
import warnings

import numpy as np
import torch
from PIL import Image
from skimage.measure import label, regionprops
from torchvision import transforms

from .utils import *

#Cell
def imresize(arr, sz):
    pim = Image.fromarray(arr)
    pim = transforms.functional.resize(pim, sz)
    return np.array(pim)

#Cell
def rescale(arr, r1, r2):
    return (arr-r1[0])/(r1[1]-r1[0])*(r2[1]-r2[0])+r2[0]

#Cell
class DotVisionCheckerDLDetector():
    def __init__(self, file_model, cuda=False):
        model = torch.jit.load(file_model.as_posix())
        model = model.cuda() if cuda else model.cpu()
        model = model.eval()

        self.cuda  = cuda
        self.model = model

    def format_arr(self, arr):
        assert_allclose(arr.dtype, np.float)        # Floating point check
        assert_allclose(len(arr.shape), 2)          # Grayscale check
        if arr.min() < 0: warnings.warn('Value less than zero detected')
        if arr.max() > 1: warnings.warn('Value greater than 1 detected')

        arr = imresize(arr, 384)                    # Network trained on grayscale 384 sized images
        arr = rescale(arr, (0, 1), (-1, 1))         # Network trained on images between [-1,1]
        arr = transforms.functional.to_tensor(arr)  # Tensorify
        arr = arr[None]                             # Add batch dimension
        if self.cuda: arr = arr.cuda()              # Possibly run on gpu
        return arr

    def get_mask(self, arr):
        model = self.model
        with torch.no_grad():
            mask = model(self.format_arr(arr))      # Inference
            mask = torch2np(mask)                   # Convert to numpy
            mask = mask.argmax(axis=1)              # Convert from scores to labels
            mask = mask.squeeze(0)                  # Remove batch dimension
        return mask

    def __call__(self, arr):
        mask = self.get_mask(arr)

        # Extract fiducial points from mask
        ps_f = np.full((4,2), np.nan)
        for idx, p_f in enumerate(ps_f):
            regions = regionprops(label(mask == (idx+1)))
            if len(regions) > 0:
                region = regions[np.argmax([r.area for r in regions])]
                p_f[:] = reverse(region.centroid)
        ps_f *= (np.array(arr.shape)/mask.shape).mean() # May not be strictly correct

        return ps_f